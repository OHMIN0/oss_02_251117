<div align="center">

# 🐧 리눅스 프로세스 관리 명령어 사용 설명
**Linux Process Management Commands Report**

![Linux](https://img.shields.io/badge/Linux-FCC624?style=flat-square&logo=linux&logoColor=black)
![Shell](https://img.shields.io/badge/Shell-121011?style=flat-square&logo=gnu-bash&logoColor=white)
![Markdown](https://img.shields.io/badge/Docs-Markdown-000000?style=flat-square&logo=markdown&logoColor=white)

<br>

> **오픈소스SW개론 과제 #2**<br>
> 리눅스 시스템 관리의 핵심인 `top`, `ps`, `jobs`, `kill`의 사용 설명을 위한 README 작성

</div>

---

### 📝 과제 제출 정보
| 항목 | 내용 |
| :---: | :--- |
| **작성자** | 20202980 오민영 |
| **제출일** | 2025년 11월 nn일 |
| **과목명** | 오픈소스SW개론 |

---

## 📑 목차 (Table of Contents)
1. [📊 top - 실시간 시스템 모니터링](#1--top---실시간-시스템-모니터링)
2. [📸 ps - 프로세스 상태 확인](#2--ps---프로세스-상태-확인-snapshot)
3. [⏯️ jobs - 백그라운드 작업 관리](#3--jobs---백그라운드-작업-관리)
4. [🔫 kill - 프로세스 종료 및 제어](#4--kill---프로세스-종료-및-시그널-전송)

---

## 1. 📊 top - 실시간 시스템 모니터링

`top` 명령어
- 리눅스 시스템의 상태를 **실시간(Real-time)**으로 갱신하며 보여주는 대시보드 역할
- Windows의 '작업 관리자'와 가장 유사함.

### 🔹 주요 특징
- **시스템 요약:** Uptime, CPU 부하(Load Average), 메모리 사용량을 상단에 표시
- **실시간 갱신:** 기본 3초 간격으로 프로세스 리스트를 업데이트
- **리소스 분석:** CPU 및 메모리를 과도하게 점유하는 프로세스 식별 가능

### 💻 실행 화면
```bash
$ top
```
> **👇 [실습 스크린샷]**
>
> <img width="796" height="227" alt="image" src="https://github.com/user-attachments/assets/0d0597d8-6538-4bba-a68e-4c2d6cecf37c" />



### 🔍 화면 상세 분석 (Screen Analysis)
`top` 실행 화면은 크게 상단의 **요약 영역**과 하단의 **프로세스 영역**으로 나뉩니다.

#### 1. 요약 영역 (Summary Area)
화면 상단 5줄에 해당하는 영역으로, 시스템 전체의 리소스 상태를 보여줍니다.
- **Tasks:** 전체 프로세스 개수 및 상태별(Running, Sleeping, Stopped, Zombie) 개수
- **%Cpu(s):** CPU 사용 현황
  - `us` (User): 사용자 프로세스(Un-niced) 사용율
  - `sy` (System): 커널(시스템) 프로세스 사용율
  - `ni` (Nice): 우선순위가 조정된(Nice) 사용자 프로세스 사용율
  - `id` (Idle): 유휴 상태 (사용되지 않는 비율)
  - `wa` (IO-wait): 디스크 I/O 작업 완료를 대기하는 시간 (높으면 디스크 병목 의심)
  - `hi` (Hardware IRQ): 하드웨어 인터럽트 처리 시간
  - `si` (Software IRQ): 소프트웨어 인터럽트 처리 시간
  - `st` (Steal Time): 하이퍼바이저에 의해 다른 가상 머신에게 CPU 자원을 빼앗긴 시간
- **MiB Mem / Swap:** 물리 메모리(RAM)와 스왑 메모리의 전체 용량, 사용량, 여유량 표시

#### 2. 프로세스 영역 (Process Area)
각 프로세스의 상세 정보를 테이블 형태로 보여줍니다.
| 필드명 | 설명 | 비고 |
| :--- | :--- | :--- |
| **PID** | 프로세스 ID (Process ID) | 각 프로세스의 고유 식별 번호 |
| **USER** | 사용자 (User) | 해당 프로세스를 실행한 사용자 이름 |
| **PR / NI** | 우선순위 (Priority / Nice) | 실행 우선순위 값 (낮을수록 높음) |
| **VIRT** | 가상 메모리 (Virtual Image) | 프로세스가 사용하는 가상 메모리 총량 |
| **RES** | 상주 메모리 (Resident Size) | 실제로 사용 중인 물리 메모리 양 |
| **SHR** | 공유 메모리 (Shared Mem) | 다른 프로세스와 공유하는 메모리 양 |
| **S** | 상태 (Status) | `R`(실행중), `S`(슬립), `Z`(좀비) 등 |
| **%CPU** | CPU 사용률 | 프로세스가 차지하는 CPU 비중 |
| **%MEM** | 메모리 사용률 | 프로세스가 차지하는 메모리 비중 |
| **TIME+** | 실행 시간 | 프로세스가 시작된 후 사용한 총 CPU 시간 |
| **COMMAND** | 명령어 | 프로세스를 실행한 명령어 이름 |

### 🎮 핵심 단축키 (Interactive Keys)
`top` 실행 중 사용할 수 있는 유용한 키 모음입니다. (대소문자 구별 주의)

#### 1. 정렬 및 필터링 (Sorting)
| 키 | 동작 |
| :---: | :--- |
| `P` | **CPU** 사용량 순서로 정렬 (기본값) |
| `M` | **메모리** 사용량 순서로 정렬 |
| `T` | 프로세스 **실행 시간** 순서로 정렬 |
| `R` | 정렬 순서 뒤집기 (오름차순/내림차순 토글) |

#### 2. 프로세스 제어 (Control)
| 키 | 동작 |
| :---: | :--- |
| `k` | 프로세스 종료 (Signal 전송, PID 입력 필요) |
| `r` | 프로세스 우선순위(Nice 값) 변경 |

#### 3. 화면 표시 설정 (Display)
| 키 | 동작 |
| :---: | :--- |
| `1` | CPU 코어별 상세 사용량 보기/접기 |
| `c` | 명령어 전체 경로(Full Path) 보기 토글 |
| `z` | 컬러 모드 켜기/끄기 (강조 표시) |
| `x` | 현재 정렬 기준이 되는 컬럼 하이라이트 |

#### 4. 기타 설정
| 키 | 동작 |
| :---: | :--- |
| `d` | 화면 갱신 주기 변경 (기본 3초) |
| `h` | 도움말 보기 |
| `q` | top 종료 |

---

## 2. 📸 ps - 프로세스 상태 확인 (Snapshot)

`ps` (Process Status)
- 명령어가 실행된 **바로 그 순간**의 프로세스 상태를 스냅샷처럼 찍어서 보여줌.

### 🔹 필수 옵션 (Flags)
아래는 가장 자주 사용되는 옵션들을 정리한 것임.

| 옵션 | 설명 | 활용 팁 |
| :---: | :--- | :--- |
| `-e` | **E**very | 시스템의 모든 프로세스를 출력 |
| `-f` | **F**ull | UID, PPID 등 상세 정보를 포함하여 출력 |
| `-a` | **A**ll | 다른 사용자의 프로세스도 함께 표시 |
| `-u` | **U**ser | 프로세스 소유자 이름, 시작 시간 등 표시 |
| `-x` | No TTY | 터미널에 종속되지 않은 데몬 프로세스 표시 |

### 💻 실행 결과 및 컬럼 분석 (`ps -aux` 기준)

<img width="763" height="77" alt="image" src="https://github.com/user-attachments/assets/ea28aa66-d3cf-4010-8d64-08954ea785d7" />


#### 🔍 컬럼(Header) 상세 설명
| 컬럼명 | 전체 이름 (Meaning) | 상세 설명 |
| :--- | :--- | :--- |
| **USER** | User Name | 프로세스를 실행시킨 사용자 계정 이름 |
| **PID** | Process ID | 시스템에서 프로세스를 식별하는 고유 번호 |
| **%CPU** | CPU Usage | 프로세스가 사용 중인 CPU 점유율 (백분율) |
| **%MEM** | Memory Usage | 프로세스가 사용 중인 물리 메모리 점유율 (백분율) |
| **VSZ** | Virtual Memory Size | 가상 메모리 사용량 (KB). 코드, 데이터, 라이브러리 등을 포함한 할당된 총 크기 |
| **RSS** | Resident Set Size | 실제 물리 메모리(RAM) 사용량 (KB). 실제 메모리에 적재된 크기 |
| **TTY** | Teletypewriter | 프로세스가 연결된 터미널 이름. (`?`는 데몬 등 터미널이 없는 경우) |
| **STAT** | Status | 프로세스의 현재 상태 코드 (아래 표 참조) |
| **START** | Start Time | 프로세스가 시작된 날짜 또는 시간 |
| **TIME** | Total CPU Time | 프로세스가 시작된 후 사용한 총 CPU 시간 합계 |
| **COMMAND** | Command line | 프로세스를 실행한 명령어 라인 (옵션 포함) |

#### 📊 STAT 상태 코드 설명
`STAT` 컬럼은 프로세스의 상태를 문자로 나타냅니다.
- **`R`**: 실행 중 (Running) 또는 실행 대기
- **`S`**: 인터럽트 가능한 수면 (Sleeping) - 이벤트 대기 중
- **`D`**: 인터럽트 불가능한 수면 (Disk Sleep) - 보통 I/O 대기
- **`Z`**: 좀비 (Zombie) - 종료되었으나 부모가 회수하지 않음
- **`T`**: 정지됨 (Stopped)
- **`+`**: 포그라운드(Foreground) 프로세스 그룹에 속함
- **`l`**: 멀티 스레드 (Multi-threaded)
- **`s`**: 세션 리더 (Session leader)

---

## 3. ⏯️ jobs - 백그라운드 작업 관리

`jobs` 명령어는 현재 쉘 세션의 **Job Control(작업 제어)** 기능을 담당하며, 백그라운드에서 실행 중이거나 중지된 작업들의 목록을 관리합니다.

### 🔹 주요 개념: 포그라운드 vs 백그라운드
- **포그라운드(Foreground):** 터미널 입력을 독점하며, 실행 중에는 다른 명령어를 입력할 수 없는 상태 (일반적인 명령어 실행)
- **백그라운드(Background):** 뒤에서 실행되며, 터미널을 계속 사용할 수 있는 상태 (명령어 뒤에 `&` 붙임)

### 💻 실행 화면 및 출력 분석
```bash
$ jobs
[1]-  Running                 sleep 1000 &
[2]+  Stopped                 vim my_code.c
```

#### 🔍 출력 필드 설명
| 출력 부분 | 의미 | 설명 |
| :--- | :--- | :--- |
| **[1], [2]** | **Job ID** | 작업 번호. PID와는 다르며, `fg`, `bg`, `kill` 등 쉘 내부 명령에서 사용 (`%1`, `%2`) |
| **`+`** | **Current** | 현재 작업(Current Job). 인자 없이 `fg`/`bg` 입력 시 적용되는 대상 |
| **`-`** | **Previous** | 이전 작업(Previous Job). `+` 작업이 끝나면 `+`가 됨 |
| **Running** | **State** | 현재 백그라운드에서 계속 실행 중인 상태 |
| **Stopped** | **State** | 실행이 일시 중지된 상태 (보통 `Ctrl + Z` 입력 시) |
| **Terminated** | **State** | 강제로 종료된 상태 (주로 `kill` 신호를 받아 강제 종료됨) |
| **Done** | **State** | 작업이 정상적으로 완료된 상태 (종료 코드 0) |
| **Exit** | **State** | 작업이 오류로 인해 종료된 상태 (비정상 종료, 종료 코드 != 0) |
| **Command** | **Command** | 실행된 명령어 라인 |

### 🎮 작업 제어 (Job Control) 방법

#### 1. 백그라운드 실행 (`&`)
명령어 뒤에 앰퍼샌드(`&`)를 붙이면 즉시 백그라운드에서 시작합니다.
```bash
$ sleep 3000 &
[1] 12345
```

#### 2. 실행 중지 (`Ctrl + Z`)
포그라운드에서 실행 중인 작업을 **일시 중지(Stopped)** 상태로 만들고 백그라운드 목록에 추가합니다.
```bash
$ vim my_text.txt
# (Ctrl + Z 입력)
[2]+  Stopped                 vim my_text.txt
```

#### 3. 작업 전환 (`fg` / `bg`)
멈춰있거나 뒤에 있는 작업을 앞으로 가져오거나, 뒤에서 계속 실행하게 합니다.
- **`fg %1`**: 1번 작업을 **포그라운드**로 가져옴 (다시 화면에 띄움)
- **`bg %2`**: 2번(Stopped 상태) 작업을 **백그라운드**에서 계속 실행되게 함 (Running 상태로 변경)

#### 4. 작업 종료 (`kill`)
Job ID를 사용하여 특정 작업을 종료합니다. `%`를 반드시 붙여야 합니다.
- **`kill %1`**: 1번 작업 종료

---

## 4. 🔫 kill - 프로세스 종료 및 시그널 전송

`kill` 명령어는 단순히 프로세스를 '죽이는' 것이 아니라, 프로세스에 **시그널(Signal)**을 전송하여 특정 행동(종료, 정지, 재시작 등)을 하도록 요청하는 명령어입니다.

### 🔹 주요 시그널 (Common Signals)
리눅스에는 64개의 시그널이 있지만, 관리자가 자주 사용하는 핵심 시그널은 다음과 같습니다.

| 번호 | 이름 | 의미 | 특징 |
| :---: | :--- | :--- | :--- |
| **1** | **SIGHUP** | Hang Up | 설정 파일 리로드(Reload) 시 주로 사용 (재시작 효과) |
| **2** | **SIGINT** | Interrupt | 키보드 `Ctrl + C` 입력과 동일. 실행 취소 요청 |
| **9** | **SIGKILL** | Kill | **강제 종료**. 프로세스가 거부하거나 무시할 수 없음 (가장 강력) |
| **15** | **SIGTERM** | Terminate | **정상 종료**. (기본값) 프로세스 스스로 정리하고 종료하도록 요청 |
| **18** | **SIGCONT** | Continue | 정지된(`T`, Stopped) 프로세스를 다시 실행 재개 |
| **19** | **SIGSTOP** | Stop | 프로세스 실행 **일시 정지**. (프로세스가 무시 불가) |

### 💻 사용 문법 및 예시
기본적으로 PID(Process ID)를 사용하지만, `%Job ID`를 사용할 수도 있습니다.

#### 1. PID로 종료하기 (가장 흔함)
```bash
$ kill 1234         # PID 1234에 SIGTERM(15) 전송 (기본값)
$ kill -9 1234      # PID 1234를 강제 종료 (SIGKILL)
```

#### 2. Job ID로 종료하기 (jobs 명령어와 연계)
```bash
$ kill %1           # jobs 목록의 [1]번 작업 종료
$ kill -9 %2        # jobs 목록의 [2]번 작업 강제 종료
```

#### 3. 프로세스 이름으로 종료하기 (killall)
PID를 일일이 찾기 귀찮을 때, 이름이 같은 모든 프로세스를 한 번에 종료합니다.
```bash
$ killall nginx     # 'nginx'라는 이름의 모든 프로세스 종료
$ killall -9 python # 'python'이라는 이름으로 실행 중인 모든 프로세스 강제 종료
```

> **🚨 안전한 종료 절차 (Safety Tip)**
>
> 무조건 `kill -9`를 사용하는 것은 좋지 않습니다. 데이터 손실이나 파일 깨짐이 발생할 수 있기 때문입니다.
> 1. 먼저 `kill -15 [PID]` (또는 그냥 `kill [PID]`)를 시도하여 정상 종료를 우선적으로 요청합니다.
> 2. 프로세스가 멈추지 않고 버틴다면, 그때 'kill -9 [PID]'를 요청하는 것을 권장합니다.

---
